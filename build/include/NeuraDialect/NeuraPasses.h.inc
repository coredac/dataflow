/* Autogenerated by mlir-tblgen; don't manually edit */

#ifdef GEN_PASS_DECL
// Generate declarations for all passes.
#define GEN_PASS_DECL_ASSIGNACCELERATOR
#define GEN_PASS_DECL_FUSEPATTERNS
#define GEN_PASS_DECL_GENERATECODE
#define GEN_PASS_DECL_INSERTCTRLMOV
#define GEN_PASS_DECL_INSERTDATAMOV
#define GEN_PASS_DECL_LEVERAGEPREDICATEDVALUE
#define GEN_PASS_DECL_MAPTOACCELERATOR
#define GEN_PASS_DECL_TRANSFORMCTRLTODATAFLOW
#undef GEN_PASS_DECL
#endif // GEN_PASS_DECL

//===----------------------------------------------------------------------===//
// AssignAccelerator
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_ASSIGNACCELERATOR
#undef GEN_PASS_DECL_ASSIGNACCELERATOR
#endif // GEN_PASS_DECL_ASSIGNACCELERATOR
#ifdef GEN_PASS_DEF_ASSIGNACCELERATOR
namespace impl {

template <typename DerivedT>
class AssignAcceleratorBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = AssignAcceleratorBase;

  AssignAcceleratorBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  AssignAcceleratorBase(const AssignAcceleratorBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  AssignAcceleratorBase& operator=(const AssignAcceleratorBase &) = delete;
  AssignAcceleratorBase(AssignAcceleratorBase &&) = delete;
  AssignAcceleratorBase& operator=(AssignAcceleratorBase &&) = delete;
  ~AssignAcceleratorBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("assign-accelerator");
  }
  ::llvm::StringRef getArgument() const override { return "assign-accelerator"; }

  ::llvm::StringRef getDescription() const override { return "Assigns accelerators to operations in the Neura dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AssignAccelerator");
  }
  ::llvm::StringRef getName() const override { return "AssignAccelerator"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AssignAcceleratorBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_ASSIGNACCELERATOR
#endif // GEN_PASS_DEF_ASSIGNACCELERATOR

//===----------------------------------------------------------------------===//
// FusePatterns
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_FUSEPATTERNS
#undef GEN_PASS_DECL_FUSEPATTERNS
#endif // GEN_PASS_DECL_FUSEPATTERNS
#ifdef GEN_PASS_DEF_FUSEPATTERNS
namespace impl {

template <typename DerivedT>
class FusePatternsBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = FusePatternsBase;

  FusePatternsBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  FusePatternsBase(const FusePatternsBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  FusePatternsBase& operator=(const FusePatternsBase &) = delete;
  FusePatternsBase(FusePatternsBase &&) = delete;
  FusePatternsBase& operator=(FusePatternsBase &&) = delete;
  ~FusePatternsBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("fuse-patterns");
  }
  ::llvm::StringRef getArgument() const override { return "fuse-patterns"; }

  ::llvm::StringRef getDescription() const override { return "Fuses patterns in the Neura dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("FusePatterns");
  }
  ::llvm::StringRef getName() const override { return "FusePatterns"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(FusePatternsBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_FUSEPATTERNS
#endif // GEN_PASS_DEF_FUSEPATTERNS

//===----------------------------------------------------------------------===//
// GenerateCode
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_GENERATECODE
#undef GEN_PASS_DECL_GENERATECODE
#endif // GEN_PASS_DECL_GENERATECODE
#ifdef GEN_PASS_DEF_GENERATECODE
namespace impl {

template <typename DerivedT>
class GenerateCodeBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = GenerateCodeBase;

  GenerateCodeBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  GenerateCodeBase(const GenerateCodeBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  GenerateCodeBase& operator=(const GenerateCodeBase &) = delete;
  GenerateCodeBase(GenerateCodeBase &&) = delete;
  GenerateCodeBase& operator=(GenerateCodeBase &&) = delete;
  ~GenerateCodeBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("generate-code");
  }
  ::llvm::StringRef getArgument() const override { return "generate-code"; }

  ::llvm::StringRef getDescription() const override { return "Generate JSON-formatted instructions from mapped Neura IR"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("GenerateCode");
  }
  ::llvm::StringRef getName() const override { return "GenerateCode"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(GenerateCodeBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_GENERATECODE
#endif // GEN_PASS_DEF_GENERATECODE

//===----------------------------------------------------------------------===//
// InsertCtrlMov
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_INSERTCTRLMOV
#undef GEN_PASS_DECL_INSERTCTRLMOV
#endif // GEN_PASS_DECL_INSERTCTRLMOV
#ifdef GEN_PASS_DEF_INSERTCTRLMOV
namespace impl {

template <typename DerivedT>
class InsertCtrlMovBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = InsertCtrlMovBase;

  InsertCtrlMovBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  InsertCtrlMovBase(const InsertCtrlMovBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  InsertCtrlMovBase& operator=(const InsertCtrlMovBase &) = delete;
  InsertCtrlMovBase(InsertCtrlMovBase &&) = delete;
  InsertCtrlMovBase& operator=(InsertCtrlMovBase &&) = delete;
  ~InsertCtrlMovBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("insert-ctrl-mov");
  }
  ::llvm::StringRef getArgument() const override { return "insert-ctrl-mov"; }

  ::llvm::StringRef getDescription() const override { return "Inserts ctrl move operations in the Neura dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("InsertCtrlMov");
  }
  ::llvm::StringRef getName() const override { return "InsertCtrlMov"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(InsertCtrlMovBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_INSERTCTRLMOV
#endif // GEN_PASS_DEF_INSERTCTRLMOV

//===----------------------------------------------------------------------===//
// InsertDataMov
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_INSERTDATAMOV
#undef GEN_PASS_DECL_INSERTDATAMOV
#endif // GEN_PASS_DECL_INSERTDATAMOV
#ifdef GEN_PASS_DEF_INSERTDATAMOV
namespace impl {

template <typename DerivedT>
class InsertDataMovBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = InsertDataMovBase;

  InsertDataMovBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  InsertDataMovBase(const InsertDataMovBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  InsertDataMovBase& operator=(const InsertDataMovBase &) = delete;
  InsertDataMovBase(InsertDataMovBase &&) = delete;
  InsertDataMovBase& operator=(InsertDataMovBase &&) = delete;
  ~InsertDataMovBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("insert-data-mov");
  }
  ::llvm::StringRef getArgument() const override { return "insert-data-mov"; }

  ::llvm::StringRef getDescription() const override { return "Inserts data move operations in the Neura dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("InsertDataMov");
  }
  ::llvm::StringRef getName() const override { return "InsertDataMov"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(InsertDataMovBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_INSERTDATAMOV
#endif // GEN_PASS_DEF_INSERTDATAMOV

//===----------------------------------------------------------------------===//
// LeveragePredicatedValue
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LEVERAGEPREDICATEDVALUE
#undef GEN_PASS_DECL_LEVERAGEPREDICATEDVALUE
#endif // GEN_PASS_DECL_LEVERAGEPREDICATEDVALUE
#ifdef GEN_PASS_DEF_LEVERAGEPREDICATEDVALUE
namespace impl {

template <typename DerivedT>
class LeveragePredicatedValueBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = LeveragePredicatedValueBase;

  LeveragePredicatedValueBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  LeveragePredicatedValueBase(const LeveragePredicatedValueBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  LeveragePredicatedValueBase& operator=(const LeveragePredicatedValueBase &) = delete;
  LeveragePredicatedValueBase(LeveragePredicatedValueBase &&) = delete;
  LeveragePredicatedValueBase& operator=(LeveragePredicatedValueBase &&) = delete;
  ~LeveragePredicatedValueBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("leverage-predicated-value");
  }
  ::llvm::StringRef getArgument() const override { return "leverage-predicated-value"; }

  ::llvm::StringRef getDescription() const override { return "Convert values to predicated values in Neura dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LeveragePredicatedValue");
  }
  ::llvm::StringRef getName() const override { return "LeveragePredicatedValue"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LeveragePredicatedValueBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LEVERAGEPREDICATEDVALUE
#endif // GEN_PASS_DEF_LEVERAGEPREDICATEDVALUE

//===----------------------------------------------------------------------===//
// MapToAccelerator
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_MAPTOACCELERATOR
#undef GEN_PASS_DECL_MAPTOACCELERATOR
#endif // GEN_PASS_DECL_MAPTOACCELERATOR
#ifdef GEN_PASS_DEF_MAPTOACCELERATOR
namespace impl {

template <typename DerivedT>
class MapToAcceleratorBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = MapToAcceleratorBase;

  MapToAcceleratorBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  MapToAcceleratorBase(const MapToAcceleratorBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  MapToAcceleratorBase& operator=(const MapToAcceleratorBase &) = delete;
  MapToAcceleratorBase(MapToAcceleratorBase &&) = delete;
  MapToAcceleratorBase& operator=(MapToAcceleratorBase &&) = delete;
  ~MapToAcceleratorBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("map-to-accelerator");
  }
  ::llvm::StringRef getArgument() const override { return "map-to-accelerator"; }

  ::llvm::StringRef getDescription() const override { return "Map Neura operations onto a given accelerator"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MapToAccelerator");
  }
  ::llvm::StringRef getName() const override { return "MapToAccelerator"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MapToAcceleratorBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_MAPTOACCELERATOR
#endif // GEN_PASS_DEF_MAPTOACCELERATOR

//===----------------------------------------------------------------------===//
// TransformCtrlToDataFlow
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRANSFORMCTRLTODATAFLOW
#undef GEN_PASS_DECL_TRANSFORMCTRLTODATAFLOW
#endif // GEN_PASS_DECL_TRANSFORMCTRLTODATAFLOW
#ifdef GEN_PASS_DEF_TRANSFORMCTRLTODATAFLOW
namespace impl {

template <typename DerivedT>
class TransformCtrlToDataFlowBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TransformCtrlToDataFlowBase;

  TransformCtrlToDataFlowBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TransformCtrlToDataFlowBase(const TransformCtrlToDataFlowBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  TransformCtrlToDataFlowBase& operator=(const TransformCtrlToDataFlowBase &) = delete;
  TransformCtrlToDataFlowBase(TransformCtrlToDataFlowBase &&) = delete;
  TransformCtrlToDataFlowBase& operator=(TransformCtrlToDataFlowBase &&) = delete;
  ~TransformCtrlToDataFlowBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("transform-ctrl-to-data-flow");
  }
  ::llvm::StringRef getArgument() const override { return "transform-ctrl-to-data-flow"; }

  ::llvm::StringRef getDescription() const override { return "Inserts ctrl move operations in the Neura dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TransformCtrlToDataFlow");
  }
  ::llvm::StringRef getName() const override { return "TransformCtrlToDataFlow"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TransformCtrlToDataFlowBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TRANSFORMCTRLTODATAFLOW
#endif // GEN_PASS_DEF_TRANSFORMCTRLTODATAFLOW
#ifdef GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// AssignAccelerator Registration
//===----------------------------------------------------------------------===//

inline void registerAssignAccelerator() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return neura::createAssignAcceleratorPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerAssignAcceleratorPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return neura::createAssignAcceleratorPass();
  });
}

//===----------------------------------------------------------------------===//
// FusePatterns Registration
//===----------------------------------------------------------------------===//

inline void registerFusePatterns() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return neura::createFusePatternsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerFusePatternsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return neura::createFusePatternsPass();
  });
}

//===----------------------------------------------------------------------===//
// GenerateCode Registration
//===----------------------------------------------------------------------===//

inline void registerGenerateCode() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return neura::createGenerateCodePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerGenerateCodePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return neura::createGenerateCodePass();
  });
}

//===----------------------------------------------------------------------===//
// InsertCtrlMov Registration
//===----------------------------------------------------------------------===//

inline void registerInsertCtrlMov() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return neura::createInsertCtrlMovPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerInsertCtrlMovPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return neura::createInsertCtrlMovPass();
  });
}

//===----------------------------------------------------------------------===//
// InsertDataMov Registration
//===----------------------------------------------------------------------===//

inline void registerInsertDataMov() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return neura::createInsertDataMovPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerInsertDataMovPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return neura::createInsertDataMovPass();
  });
}

//===----------------------------------------------------------------------===//
// LeveragePredicatedValue Registration
//===----------------------------------------------------------------------===//

inline void registerLeveragePredicatedValue() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return neura::createLeveragePredicatedValuePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLeveragePredicatedValuePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return neura::createLeveragePredicatedValuePass();
  });
}

//===----------------------------------------------------------------------===//
// MapToAccelerator Registration
//===----------------------------------------------------------------------===//

inline void registerMapToAccelerator() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return neura::createMapToAcceleratorPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerMapToAcceleratorPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return neura::createMapToAcceleratorPass();
  });
}

//===----------------------------------------------------------------------===//
// TransformCtrlToDataFlow Registration
//===----------------------------------------------------------------------===//

inline void registerTransformCtrlToDataFlow() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return neura::createTransformCtrlToDataFlowPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTransformCtrlToDataFlowPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return neura::createTransformCtrlToDataFlowPass();
  });
}

//===----------------------------------------------------------------------===//
//  Registration
//===----------------------------------------------------------------------===//

inline void registerPasses() {
  registerAssignAccelerator();
  registerFusePatterns();
  registerGenerateCode();
  registerInsertCtrlMov();
  registerInsertDataMov();
  registerLeveragePredicatedValue();
  registerMapToAccelerator();
  registerTransformCtrlToDataFlow();
}
#undef GEN_PASS_REGISTRATION
#endif // GEN_PASS_REGISTRATION
// Deprecated. Please use the new per-pass macros.
#ifdef GEN_PASS_CLASSES

template <typename DerivedT>
class AssignAcceleratorBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = AssignAcceleratorBase;

  AssignAcceleratorBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  AssignAcceleratorBase(const AssignAcceleratorBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  AssignAcceleratorBase& operator=(const AssignAcceleratorBase &) = delete;
  AssignAcceleratorBase(AssignAcceleratorBase &&) = delete;
  AssignAcceleratorBase& operator=(AssignAcceleratorBase &&) = delete;
  ~AssignAcceleratorBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("assign-accelerator");
  }
  ::llvm::StringRef getArgument() const override { return "assign-accelerator"; }

  ::llvm::StringRef getDescription() const override { return "Assigns accelerators to operations in the Neura dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AssignAccelerator");
  }
  ::llvm::StringRef getName() const override { return "AssignAccelerator"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AssignAcceleratorBase<DerivedT>)

protected:
};

template <typename DerivedT>
class FusePatternsBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = FusePatternsBase;

  FusePatternsBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  FusePatternsBase(const FusePatternsBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  FusePatternsBase& operator=(const FusePatternsBase &) = delete;
  FusePatternsBase(FusePatternsBase &&) = delete;
  FusePatternsBase& operator=(FusePatternsBase &&) = delete;
  ~FusePatternsBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("fuse-patterns");
  }
  ::llvm::StringRef getArgument() const override { return "fuse-patterns"; }

  ::llvm::StringRef getDescription() const override { return "Fuses patterns in the Neura dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("FusePatterns");
  }
  ::llvm::StringRef getName() const override { return "FusePatterns"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(FusePatternsBase<DerivedT>)

protected:
};

template <typename DerivedT>
class GenerateCodeBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = GenerateCodeBase;

  GenerateCodeBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  GenerateCodeBase(const GenerateCodeBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  GenerateCodeBase& operator=(const GenerateCodeBase &) = delete;
  GenerateCodeBase(GenerateCodeBase &&) = delete;
  GenerateCodeBase& operator=(GenerateCodeBase &&) = delete;
  ~GenerateCodeBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("generate-code");
  }
  ::llvm::StringRef getArgument() const override { return "generate-code"; }

  ::llvm::StringRef getDescription() const override { return "Generate JSON-formatted instructions from mapped Neura IR"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("GenerateCode");
  }
  ::llvm::StringRef getName() const override { return "GenerateCode"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(GenerateCodeBase<DerivedT>)

protected:
};

template <typename DerivedT>
class InsertCtrlMovBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = InsertCtrlMovBase;

  InsertCtrlMovBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  InsertCtrlMovBase(const InsertCtrlMovBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  InsertCtrlMovBase& operator=(const InsertCtrlMovBase &) = delete;
  InsertCtrlMovBase(InsertCtrlMovBase &&) = delete;
  InsertCtrlMovBase& operator=(InsertCtrlMovBase &&) = delete;
  ~InsertCtrlMovBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("insert-ctrl-mov");
  }
  ::llvm::StringRef getArgument() const override { return "insert-ctrl-mov"; }

  ::llvm::StringRef getDescription() const override { return "Inserts ctrl move operations in the Neura dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("InsertCtrlMov");
  }
  ::llvm::StringRef getName() const override { return "InsertCtrlMov"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(InsertCtrlMovBase<DerivedT>)

protected:
};

template <typename DerivedT>
class InsertDataMovBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = InsertDataMovBase;

  InsertDataMovBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  InsertDataMovBase(const InsertDataMovBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  InsertDataMovBase& operator=(const InsertDataMovBase &) = delete;
  InsertDataMovBase(InsertDataMovBase &&) = delete;
  InsertDataMovBase& operator=(InsertDataMovBase &&) = delete;
  ~InsertDataMovBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("insert-data-mov");
  }
  ::llvm::StringRef getArgument() const override { return "insert-data-mov"; }

  ::llvm::StringRef getDescription() const override { return "Inserts data move operations in the Neura dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("InsertDataMov");
  }
  ::llvm::StringRef getName() const override { return "InsertDataMov"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(InsertDataMovBase<DerivedT>)

protected:
};

template <typename DerivedT>
class LeveragePredicatedValueBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = LeveragePredicatedValueBase;

  LeveragePredicatedValueBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  LeveragePredicatedValueBase(const LeveragePredicatedValueBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  LeveragePredicatedValueBase& operator=(const LeveragePredicatedValueBase &) = delete;
  LeveragePredicatedValueBase(LeveragePredicatedValueBase &&) = delete;
  LeveragePredicatedValueBase& operator=(LeveragePredicatedValueBase &&) = delete;
  ~LeveragePredicatedValueBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("leverage-predicated-value");
  }
  ::llvm::StringRef getArgument() const override { return "leverage-predicated-value"; }

  ::llvm::StringRef getDescription() const override { return "Convert values to predicated values in Neura dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LeveragePredicatedValue");
  }
  ::llvm::StringRef getName() const override { return "LeveragePredicatedValue"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LeveragePredicatedValueBase<DerivedT>)

protected:
};

template <typename DerivedT>
class MapToAcceleratorBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = MapToAcceleratorBase;

  MapToAcceleratorBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  MapToAcceleratorBase(const MapToAcceleratorBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  MapToAcceleratorBase& operator=(const MapToAcceleratorBase &) = delete;
  MapToAcceleratorBase(MapToAcceleratorBase &&) = delete;
  MapToAcceleratorBase& operator=(MapToAcceleratorBase &&) = delete;
  ~MapToAcceleratorBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("map-to-accelerator");
  }
  ::llvm::StringRef getArgument() const override { return "map-to-accelerator"; }

  ::llvm::StringRef getDescription() const override { return "Map Neura operations onto a given accelerator"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MapToAccelerator");
  }
  ::llvm::StringRef getName() const override { return "MapToAccelerator"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MapToAcceleratorBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TransformCtrlToDataFlowBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TransformCtrlToDataFlowBase;

  TransformCtrlToDataFlowBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TransformCtrlToDataFlowBase(const TransformCtrlToDataFlowBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  TransformCtrlToDataFlowBase& operator=(const TransformCtrlToDataFlowBase &) = delete;
  TransformCtrlToDataFlowBase(TransformCtrlToDataFlowBase &&) = delete;
  TransformCtrlToDataFlowBase& operator=(TransformCtrlToDataFlowBase &&) = delete;
  ~TransformCtrlToDataFlowBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("transform-ctrl-to-data-flow");
  }
  ::llvm::StringRef getArgument() const override { return "transform-ctrl-to-data-flow"; }

  ::llvm::StringRef getDescription() const override { return "Inserts ctrl move operations in the Neura dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TransformCtrlToDataFlow");
  }
  ::llvm::StringRef getName() const override { return "TransformCtrlToDataFlow"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TransformCtrlToDataFlowBase<DerivedT>)

protected:
};
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES
