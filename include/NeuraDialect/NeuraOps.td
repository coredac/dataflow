// NeuraOps.td - Custom operation definitions.

include "NeuraDialect/NeuraDialect.td"

// ----------------------------------------------------
// Defines basic scalar operations.

def Neura_ConstantOp : Op<NeuraDialect, "constant"> {
  let arguments = (ins 
    AnyAttr:$value,
    OptionalAttr<BoolAttr>:$predicate  // Add optional predicate attribute
  );
  let results = (outs AnyType:$result);
  // let assemblyFormat = "attr-dict `:` type($result)";
}

// Defines an addition operation.
def Neura_AddOp : Op<NeuraDialect, "add"> {
  let summary = "Integer addition operation";
  let opName = "add";
  let arguments = (ins AnyType:$lhs, AnyType:$rhs, Optional<AnyType>:$predicate);
  let results = (outs AnyType:$result);
  // let assemblyFormat = "$lhs `,` $rhs `,` $predicate attr-dict `:` type($result)";
  let traits = [SameOperandsAndResultElementType];
}

// Defines a floating-point addition operation.
def Neura_FAddOp : Op<NeuraDialect, "fadd"> {
  let summary = "Floating addition operation";
  let opName = "fadd";
  let arguments = (ins AnyType:$lhs, AnyType:$rhs, Optional<AnyType>:$predicate);
  let results = (outs AnyType:$result);
  // let assemblyFormat = "$lhs `,` $rhs `,` $predicate attr-dict `:` type($result)";
  //let traits = [SameOperandsAndResultElementType];
}

// Defines a floating-point substraction operation.
def Neura_FSubOp: Op<NeuraDialect, "fsub"> {
  let summary = "Floating substraction operation";
  let opName = "fsub";
  let arguments = (ins AnyFloat:$lhs, AnyFloat:$rhs);
  let results = (outs AnyFloat:$result);
  // let assemblyFormat = "$lhs `,` $rhs attr-dict `:` type($result)";
  let traits = [SameOperandsAndResultElementType];
}

// Defines a floating-point multiplication operation.
def Neura_FMulOp : Op<NeuraDialect, "fmul"> {
  let summary = "Floating multiplication operation";
  let opName = "fmul";
  let arguments = (ins AnyType:$lhs, AnyType:$rhs, Optional<AnyType>:$predicate);
  let results = (outs AnyType:$result);
  // let assemblyFormat = "$lhs `,` $rhs `,` $predicate attr-dict `:` type($result)";
  // let traits = [SameOperandsAndResultElementType];
}

// Defines a bitwise OR operation.
def Neura_OrOp : Op<NeuraDialect, "or"> {
  let summary = "Bitwise OR operation";
  let arguments = (ins AnySignlessInteger:$lhs, AnySignlessInteger:$rhs, Optional<AnyType>:$predicate);
  let results = (outs AnySignlessInteger:$result);
  // let assemblyFormat = "$lhs `,` $rhs `,` $predicate attr-dict `:` type($result)";
  let traits = [SameOperandsAndResultElementType];
}

// Defines an integer compare operation.
def Neura_ICmpOp : Op<NeuraDialect, "icmp"> {
  let summary = "Integer compare operation";
  let opName = "icmp";
  let arguments = (ins AnyType:$lhs, AnyType:$rhs, Optional<AnyType>:$predicate,
                   StrAttr:$cmpType);
  let results = (outs AnyType:$result);
  // let assemblyFormat = "$lhs `,` $rhs `,` $cmpTypeAttr `,` $cmp_type attr-dict `:` type($result)";
  // let traits = [SameOperandsAndResultElementType];
}

// Defines a floating-point compare operation.
def Neura_FCmpOp : Op<NeuraDialect, "fcmp"> {
  let summary = "Floating-point compare operation";
  let opName = "fcmp";
  let arguments = (ins AnyFloat:$lhs,
                   AnyFloat:$rhs,
                   Optional<AnyType>:$predicate,
                   StrAttr:$cmpType);
  let results = (outs I1:$result);
  // let assemblyFormat = "$lhs `,` $rhs `,` $cmpType attr-dict `:` type($result)";
  // let traits = [SameOperandsAndResultElementType];
}

// Defines a load operation.
def Neura_LoadOp : Op<NeuraDialect, "load"> {
  let arguments = (ins AnyType:$addr, Optional<AnyType>:$predicate);
  let results = (outs AnyType:$value);
  // let assemblyFormat = "$addr `,` $predicate attr-dict `:` type($value)";
}

// Defines a store operation.
def Neura_StoreOp : Op<NeuraDialect, "store"> {
  let arguments = (ins AnyType:$value, AnyType:$addr, Optional<AnyType>:$predicate);
  let results = (outs);
  // let assemblyFormat = "$value `,` $addr `,` $predicate attr-dict";
}

// Defines a load operation with integrated address calculation.
def Neura_LoadIndexedOp: Op<NeuraDialect, "load_indexed", [AttrSizedOperandSegments]>{
  let summary = "Load with integrated address calculation for multi-dimensional arrays";
  let description = [{
    Calculates the address using the base address and indices.
    Load the value at the calculated address.
    Example:
      %value = neura.load_indexed %base [%arg1, %arg2] : f32
  }];
  let arguments = (ins Arg<AnyMemRef, "the load operation">:$base, Variadic<Index>:$indices, Optional<AnyType>:$predicate);
  let results = (outs AnyType:$result);
  let assemblyFormat = "type($base) $base `[` $indices `]` ($predicate^ `:` type($predicate))? attr-dict `:` type($result)";
}

//Defines a store operation with integrated address calculation.
def Neura_StoreIndexedOp: Op<NeuraDialect, "store_indexed", [AttrSizedOperandSegments]> {
  let summary = "Store with integrated address calculation for multi-dimensional arrays";
  let description = [{
    Calculates the address using the base address and indices.
    Store the value at the calculated address.
    Example:
      neura.store_indexed %value, %base [%arg1, %arg2] : f32
  }];
  let arguments = (ins AnyType:$value, Arg<AnyMemRef, "the store operation">:$base, Variadic<Index>:$indices, Optional<AnyType>:$predicate);
  let results = (outs);
  let assemblyFormat = "$value `to` type($base) $base `[` $indices `]` ($predicate^ `:` type($predicate))? attr-dict `:` type($value)";
}

// Defines a pointer computation operation.
def Neura_GEP : Op<NeuraDialect, "gep"> {
  let summary = "Pointer computation using offset indices";
  let arguments = (ins AnyType:$base, Variadic<AnyInteger>:$indicesAndPredicate);
  let results = (outs AnyType:$result);
  // let assemblyFormat = "$base `[` $indicesAndPredicate `]` `,` $predicate attr-dict";
}

// Defines a conditional branch operation.
def Neura_CondBr : Op<NeuraDialect, "cond_br", [Terminator, AttrSizedOperandSegments]> {
  let arguments = (ins AnyType:$condition,
                   Optional<AnyType>:$predicate,
                   Variadic<AnyType>:$trueArgs,
                   Variadic<AnyType>:$falseArgs);
  let successors = (successor AnySuccessor:$trueDest, AnySuccessor:$falseDest);
  let assemblyFormat = "$condition `:` type($condition) ($predicate^ `:` type($predicate))? `then` ($trueArgs^)? `:` type($trueArgs) `to` $trueDest `else` ($falseArgs^)? `:` type($falseArgs) `to` $falseDest attr-dict";
}

// Defines an unconditional branch operation.
def Neura_Br : Op<NeuraDialect, "br", [Terminator]> {
  let arguments = (ins Variadic<AnyType>:$args);
  let successors = (successor AnySuccessor:$dest);
  let assemblyFormat = "($args^)? `:` type($args) `to` $dest attr-dict";
}

def Neura_SelOp : Op<NeuraDialect, "sel"> {
  let arguments = (ins AnyType:$ifTrue, AnyType:$ifFalse, I1:$cond);
  let results = (outs AnyType:$result);
  // let assemblyFormat = "$ifTrue `,` $ifFalse `,` $cond attr-dict `:` type($ifTrue)";
}

def Neura_NotOp : Op<NeuraDialect, "not"> {
  let arguments = (ins I1:$input);
  let results = (outs I1:$output);
  // let assemblyFormat = "$input attr-dict `:` type($output)";
}

// Defines a return operation.
def Neura_ReturnOp : Op<NeuraDialect, "return", [Terminator]> {
  let arguments = (ins Variadic<AnyType>:$values);
  // let assemblyFormat = "($values^)? `,` $predicate attr-dict";
}

// ----------------------------------------------------
// Defines vector operations.

def VectorOfAnyFloat :
  TypeConstraint<
    CPred<
      "mlir::isa<::mlir::VectorType>($_self) && "
      "mlir::isa<::mlir::FloatType>(mlir::cast<::mlir::VectorType>($_self).getElementType())"
    >,
    "vector of floats"
  >;

// Defines a vector multiplication operation.
def Neura_VFMulOp : Op<NeuraDialect, "vfmul"> {
  let summary = "Vector floating multiplication operation";
  let opName = "vfmul";
  let arguments = (ins VectorOfAnyFloat:$lhs, VectorOfAnyFloat:$rhs, Optional<AnyType>:$predicate);
  let results = (outs VectorOfAnyFloat:$result);
  // let assemblyFormat = "$lhs `,` $rhs `,` $predicate attr-dict `:` type($result)";
  let traits = [SameOperandsAndResultElementType];
}

// ----------------------------------------------------
// Defines fused operations.

def Neura_FAddFAddOp : Op<NeuraDialect, "fadd_fadd"> {
  let summary = "Fused fadd(fadd(a, b), c)";
  let arguments = (ins AnyFloat:$a, AnyFloat:$b, AnyFloat:$c, Optional<AnyType>:$predicate);
  let results = (outs AnyFloat:$result);
  // let assemblyFormat = "$a `,` $b `,` $c `,` $predicate attr-dict `:` type($result)";
  let traits = [SameOperandsAndResultElementType];
}

def Neura_FMulFAddOp : Op<NeuraDialect, "fmul_fadd"> {
  let summary = "Fused fadd(fmul(a, b), c)";
  let arguments = (ins AnyFloat:$a, AnyFloat:$b, AnyFloat:$c, Optional<AnyType>:$predicate);
  let results = (outs AnyFloat:$result);
  // let assemblyFormat = "$a `,` $b `,` $c `,` $predicate attr-dict `:` type($result)";
  let traits = [SameOperandsAndResultElementType];
}

// ----------------------------------------------------
// Defines move operations.
def Neura_DataMovOp : Op<NeuraDialect, "data_mov"> {
  let summary = "Data movement operation";
  let arguments = (ins AnyType:$input);
  let results = (outs AnyType:$output);
  // let assemblyFormat = "$input attr-dict `:` type($input) `->` type($output)";
}

// ----------------------------------------------------
// Defines ctrl-related operations.

// Phi operation for merging values in dataflow form
def Neura_PhiOp : Op<NeuraDialect, "phi"> {
  let summary = "Phi node in dataflow form";
  let description = [{
    Merges values from different control paths in dataflow form.
    Used with reserve and ctrl_mov to represent control flow.
    
    Example:
      %v = neura.reserve : f32           // Create placeholder
      %result = neura.phi %init, %v      // Merge initial and loop-carried values
      neura.ctrl_mov %next to %v         // Connect next iteration
  }];

  let arguments = (ins Variadic<AnyType>:$inputs);
  let results = (outs AnyType:$result);

  // Explicitly specify types for operands in the assembly format
  // let assemblyFormat = "$init_val `:` type($init_val) `,` $loop_val `:` type($loop_val) attr-dict `,` type($result)";
}

// Control movement extending base move but with different signature.
def Neura_CtrlMovOp : Op<NeuraDialect, "ctrl_mov"> {
  let summary = "Control movement operation";
  let description = [{
    Connects a value to a reserved placeholder in the dataflow.
    Used to establish control flow dependencies.

    Example:
      ctrl_mov %value to %placeholder : f32  // Connect value to placeholder
  }];

  // Add type constraints for both operands
  let arguments = (ins AnyType:$value, AnyType:$target);
  let results = (outs);

  // Correct assembly format - types must be space-separated
  let assemblyFormat = "$value `->` $target attr-dict `:` type($value) type($target)";
}

// Reserve operation for control flow values.
def Neura_ReserveOp : Op<NeuraDialect, "reserve"> {
  let summary = "Creates a placeholder for control flow values";
  let description = [{
    Creates a placeholder value that will be connected via ctrl_mov.
    Used to represent control flow dependencies in dataflow form.
    
    Example:
      %v = neura.reserve : f32      // Create placeholder
      %result = neura.phi %init, %v // Use in phi node
      neura.ctrl_mov %next to %v    // Connect value
  }];

  let arguments = (ins);
  let results = (outs AnyType:$result);
  let assemblyFormat = "attr-dict `:` type($result)";
}

// ----------------------------------------------------
// Defines loop related operations.

// Loop iteration operation for index increament and compare
// TODO: Add support for more complex loop structures using LoopInterOp
def Neura_LoopIterOp : Op<NeuraDialect, "loop_iter", [AttrSizedOperandSegments]> {
  let summary = "CGRA-optimized loop iteration operation";
  let description = [{
    Takes the current loop index, a step value, and an upper bound as the inputs.
    Outputs the next loop index and a boolean condition indicating whether the loop should continue.
    
    Example:
      %next_index, %continue = neura.loop_control current_index: 0, step: 1, bound: 10 : i32 i1}];

  let arguments = (ins Index: $current_index, 
                   Index:$step, 
                   Index:$bound,
                   Optional<AnyType>:$loop_type, // 0: <, 1: <=, 2: >, 3: >=
                   Optional<AnyType>:$predicate);
  let results = (outs Index:$next_index, I1:$continue_condition);
  let assemblyFormat = "`current_index` `:` $current_index `,` `step` `:` $step `,` `bound` `:` $bound `:` type($bound) ($loop_type^ `:` type($loop_type))? ($predicate^ `:` type($predicate))? attr-dict `:` type($next_index) type($continue_condition)";
}

// Loop control operation that integrates loop iteration and control flow.
def Neura_LoopControlOp: Op<NeuraDialect, "loop_control", [Terminator]>{
  let summary = "Intergrated loop control operation for simple loops";
  let description = [{
    This operation is an integrated loop control operation that combines the loop iteration and control flow.
    It has three main actions:
    1. Calculates the next iteration's index: `next_index = current_index + step`
    2. Checks if the loop should continue based on the current index and bound.
    3. If the loop should continue, it branches to the loop body, and yields related values.
    4. Otherwise, it exits the loop.
  }];
  let arguments = (ins Index:$current_index, // Current loop index
                   Index:$step,
                   Index:$bound, 
                   DefaultValuedAttr<StrAttr, "\"lt\"">:$loop_type, // Loop type: "lt", "le", "gt", "ge", "eq", "ne"
                   Variadic<AnyType>:$body_args // Additional arguments to pass through to the successors
                   );
  let results = (outs);
  let successors = (successor
                    AnySuccessor:$body, // loop body successors
                    AnySuccessor:$exit // exit successors
                    );
  let assemblyFormat = "`current_index` `:` $current_index `,` `step` `:` $step `,` `bound` `:` $bound `,` `loop_type` `:` $loop_type `then` $body(`(`$body_args^ `:` type($body_args)`)`)? `else` $exit attr-dict";
}